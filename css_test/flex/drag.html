<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>拽</title>

    <style>
        * {
            padding: 0;
            margin: 0;
            box-sizing: border-box;
        }

        .box {
            display: flex;
            height: 500px;
            width: 100%;
            align-items: center;
            border: 1px solid red;
        }

        .left {
            /*flex-basis: 500px;*/
            min-width: 500px;

            height: 80%;
            background-color: #00d6b2;

            position: relative;
        }

        .left .line {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            width: 5px;
            z-index: 1;
            cursor: ew-resize;
        }

        .right {
            flex-grow: 1;
            height: 80%;
            background-color: blue;

            min-width: 300px;
        }
    </style>
</head>
<body>
    <div class="box">
        <div class="left">
            <div class="line" onmousedown="dragLine(event)"></div>
        </div>
        <div class="right"></div>
    </div>

    <script>
        function dragLine(e) {
          let isResize = false
          // 鼠标指针向对于浏览器页面（或客户区）的水平坐标
          let posX = e.clientX

          let leftDom = document.querySelector('.left')
          // 返回当前元素左上角相对于 HTMLElement.offsetParent 节点的左边界偏移的像素值
          let offsetL = leftDom.offsetLeft + document.body.scrollLeft
          let width = leftDom.offsetWidth

          if (posX > (offsetL + width - 10)) {
            isResize = true
          }
          document.onmousemove = throttle(function (e) {
            if (isResize) {
              leftDom.style.width = width + (e.clientX - posX) + 'px'
              console.log(leftDom.style.width)
            }
          }, 16)
          document.onmouseup = function () {
            document.onmousemove = null
            document.onmouseup = null
            document.mousedown = null
          }
        }

        function throttle(func, wait, options) {
          var context, args, result;
          var timeout = null;
          var previous = 0;
          if (!options) options = {};
          var later = function() {
            previous = options.leading === false ? 0 : new Date().getTime();
            timeout = null;
            result = func.apply(context, args);
            if (!timeout) context = args = null;
          };
          return function() {
            var now = new Date().getTime();
            if (!previous && options.leading === false) previous = now;
            var remaining = wait - (now - previous);
            context = this;
            args = arguments;
            if (remaining <= 0 || remaining > wait) {
              if (timeout) {
                clearTimeout(timeout);
                timeout = null;
              }
              previous = now;
              result = func.apply(context, args);
              if (!timeout) context = args = null;
            } else if (!timeout && options.trailing !== false) {
              timeout = setTimeout(later, remaining);
            }
            return result;
          };
        }
    </script>
</body>
</html>